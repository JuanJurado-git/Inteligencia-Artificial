. Importaci√≥n de librer√≠as

numpy: para manejar arreglos num√©ricos.

skfuzzy y skfuzzy.control: para crear y manejar l√≥gica difusa.

tkinter: para la interfaz gr√°fica.

messagebox: para mostrar alertas y mensajes emergentes.

2. Definici√≥n de variables difusas

Se crean tres variables:

Entrada (Antecedentes):

asistencia: porcentaje de asistencia (0 a 100).

nota: promedio de notas (0 a 10).

Salida (Consecuente):

desempeno: evaluaci√≥n del desempe√±o (0 a 100).

3. Definici√≥n de conjuntos difusos (funciones de membres√≠a)

Para cada variable, se definen funciones de membres√≠a triangulares que indican qu√© tan "bajo", "medio", o "alto" es un valor.

Para asistencia:

baja: 0 a 60%

media: 40 a 90%

alta: 60 a 100%

Para nota:

bajo: 0 a 6

medio: 4 a 8

alto: 6 a 10

Para desempe√±o:

deficiente: 0 a 50

aceptable: 40 a 75

excelente: 70 a 100

Estas funciones permiten que un valor no pertenezca solo a un conjunto, sino parcialmente a varios (por ejemplo, una asistencia del 65% podr√≠a ser parte de "media" y "alta").

4. Definici√≥n de reglas difusas

Se crean reglas para evaluar el desempe√±o en funci√≥n de la asistencia y la nota, por ejemplo:

Si la asistencia es baja y la nota es baja, entonces el desempe√±o es deficiente.

Si la asistencia es alta y la nota es alta, el desempe√±o es excelente.

Y otras combinaciones que cubren diferentes casos.

5. Creaci√≥n del sistema y simulador de l√≥gica difusa

Se crea un sistema de control basado en las reglas y un simulador para evaluar datos de entrada.

6. Interfaz gr√°fica (con Tkinter)

Se construye una ventana donde:

Primero pide el nombre del usuario (login simple).

Luego pide ingresar porcentaje de asistencia y nota promedio.

Al presionar "Evaluar", se ejecuta el sistema difuso con esos datos.

Muestra:

Grados de pertenencia (fuzzificaci√≥n) para asistencia y nota.

Reglas aplicadas.

Resultado difuso (desempe√±o).

Evaluaci√≥n final en texto (deficiente, aceptable, excelente).

7. Ejecuci√≥n principal

Se crea la ventana y se inicia la aplicaci√≥n gr√°fica.




import numpy as np
import skfuzzy as fuzz
import skfuzzy.control as ctrl
import tkinter as tk
from tkinter import messagebox

# SISTEMA DIFUSO SKFUZZY

# 1. Definici√≥n de variables de entrada y salida
asistencia = ctrl.Antecedent(np.arange(0, 101, 1), 'asistencia')  # porcentaje 0-100
nota = ctrl.Antecedent(np.arange(0, 11, 0.1), 'nota')             # nota 0-10
desempeno = ctrl.Consequent(np.arange(0, 101, 1), 'desempe√±o')    # desempe√±o 0-100

# 2. Definici√≥n de conjuntos difusos con funciones de membres√≠a triangulares
asistencia['baja'] = fuzz.trimf(asistencia.universe, [0, 0, 60])
asistencia['media'] = fuzz.trimf(asistencia.universe, [40, 70, 90])
asistencia['alta'] = fuzz.trimf(asistencia.universe, [60, 100, 100])

nota['bajo'] = fuzz.trimf(nota.universe, [0, 0, 6])
nota['medio'] = fuzz.trimf(nota.universe, [4, 6, 8])
nota['alto'] = fuzz.trimf(nota.universe, [6, 10, 10])

desempeno['deficiente'] = fuzz.trimf(desempeno.universe, [0, 30, 50])
desempeno['aceptable'] = fuzz.trimf(desempeno.universe, [40, 60, 75])
desempeno['excelente'] = fuzz.trimf(desempeno.universe, [70, 90, 100])

# 3. Reglas difusas que relacionan asistencia y nota con el desempe√±o
reglas = [
    ctrl.Rule(asistencia['baja'] & nota['bajo'], desempeno['deficiente']),
    ctrl.Rule(asistencia['media'] & nota['medio'], desempeno['aceptable']),
    ctrl.Rule(asistencia['alta'] & nota['alto'], desempeno['excelente']),
    ctrl.Rule(asistencia['media'] & nota['alto'], desempeno['aceptable']),
    ctrl.Rule(asistencia['alta'] & nota['medio'], desempeno['aceptable']),
    ctrl.Rule(asistencia['baja'] & nota['alto'], desempeno['aceptable']),
    ctrl.Rule(asistencia['alta'] & nota['bajo'], desempeno['deficiente'])
]

# 4. Creaci√≥n del sistema difuso y simulador
sistema_ctrl = ctrl.ControlSystem(reglas)
evaluador = ctrl.ControlSystemSimulation(sistema_ctrl)

# 5. Interfaz gr√°fica con Tkinter para interacci√≥n con el usuario
class StudentFuzzyGUI:
    def __init__(self, root):
        # Inicializaci√≥n de la ventana principal
        self.root = root
        self.root.title("Evaluador Difuso de Estudiantes")
        self.root.geometry("850x600")
        self.root.configure(bg="#e0f7fa")
        self.username = ""
        self.create_login_screen()

    def create_login_screen(self):
        # Pantalla para ingresar el nombre del usuario
        for widget in self.root.winfo_children():
            widget.destroy()
        tk.Label(self.root, text="Sistema difuso de evaluaci√≥n acad√©mica", font=("Helvetica", 18), bg="#e0f7fa").pack(pady=40)
        tk.Label(self.root, text="Ingrese su nombre:", font=("Helvetica", 14), bg="#e0f7fa").pack()
        self.username_entry = tk.Entry(self.root, font=("Helvetica", 14))
        self.username_entry.pack(pady=10)
        tk.Button(self.root, text="Ingresar", font=("Helvetica", 14), command=self.start_system, bg="#00796b", fg="white").pack(pady=20)

    def start_system(self):
        # Valida el nombre y pasa a la pantalla principal
        name = self.username_entry.get().strip()
        if not name:
            messagebox.showwarning("Advertencia", "Debe ingresar un nombre.")
            return
        self.username = name
        self.create_main_screen()

    def create_main_screen(self):
        # Pantalla principal para ingresar datos y evaluar
        for widget in self.root.winfo_children():
            widget.destroy()
        tk.Label(self.root, text=f"Hola, {self.username}", font=("Helvetica", 16, "bold"), bg="#e0f7fa").pack(pady=10)
        tk.Label(self.root, text="Ingrese el porcentaje de asistencia (%):", font=("Helvetica", 14), bg="#e0f7fa").pack()
        self.att_entry = tk.Entry(self.root, font=("Helvetica", 14))
        self.att_entry.pack(pady=5)
        tk.Label(self.root, text="Ingrese el promedio de notas (0-10):", font=("Helvetica", 14), bg="#e0f7fa").pack()
        self.grade_entry = tk.Entry(self.root, font=("Helvetica", 14))
        self.grade_entry.pack(pady=5)
        tk.Button(self.root, text="Evaluar", font=("Helvetica", 14), command=self.process_input, bg="#0288d1", fg="white").pack(pady=20)
        self.result_text = tk.Text(self.root, height=20, font=("Courier", 11), width=95, bg="#ffffff", wrap="word")
        self.result_text.pack(pady=10)

    def process_input(self):
        # Procesa los datos ingresados y eval√∫a con l√≥gica difusa
        try:
            att = float(self.att_entry.get())
            grade = float(self.grade_entry.get())
            if not (0 <= att <= 100) or not (0 <= grade <= 10):
                raise ValueError
        except ValueError:
            messagebox.showerror("Error", "Ingrese valores v√°lidos (Asistencia 0-100, Nota 0-10).")
            return

        # Realiza la evaluaci√≥n con el sistema difuso
        evaluador.input['asistencia'] = att
        evaluador.input['nota'] = grade
        evaluador.compute()
        resultado = evaluador.output['desempe√±o']

        # Mostrar resultados en la interfaz
        self.result_text.delete(1.0, tk.END)
        self.result_text.insert(tk.END, "------ FUSIFICACI√ìN ------\n")
        # Mostrar grado de pertenencia para asistencia
        for name, mf in asistencia.terms.items():
            val = fuzz.interp_membership(asistencia.universe, mf.mf, att)
            self.result_text.insert(tk.END, f"Asistencia '{name}': {val:.2f}\n")
        # Mostrar grado de pertenencia para nota
        for name, mf in nota.terms.items():
            val = fuzz.interp_membership(nota.universe, mf.mf, grade)
            self.result_text.insert(tk.END, f"Nota '{name}': {val:.2f}\n")

        self.result_text.insert(tk.END, "\n------ REGLAS APLICADAS ------\n")
        for idx, rule in enumerate(sistema_ctrl.rules):
            a = rule.antecedent
            self.result_text.insert(tk.END, f"Regla {idx+1}: SI {a} ‚Üí {rule.consequent}\n")

        self.result_text.insert(tk.END, "\n------ DESFUSIFICACI√ìN ------\n")
        self.result_text.insert(tk.END, f"Resultado final (desempe√±o): {resultado:.2f} / 100\n")

        # Evaluaci√≥n final basada en el resultado
        self.result_text.insert(tk.END, "\n------ EVALUACI√ìN FINAL ------\n")
        if resultado < 50:
            estado = "RENDIMIENTO DEFICIENTE - Se recomienda reforzar el estudio y mejorar la asistencia."
        elif resultado < 75:
            estado = "RENDIMIENTO ACEPTABLE - Buen trabajo, sigue as√≠."
        else:
            estado = "RENDIMIENTO EXCELENTE - ¬°Felicidades!"

        self.result_text.insert(tk.END, f"Estado del estudiante: {estado}\n")


# EJECUCI√ìN DEL SISTEMA: Inicializa la interfaz gr√°fica y el sistema
if __name__ == "__main__":
    root = tk.Tk()
    app = StudentFuzzyGUI(root)
    root.mainloop()

‚úÖ ¬øQu√© hace root en app = StudentFuzzyGUI(root)?

root es la ventana principal de la interfaz gr√°fica de usuario (GUI) creada con tkinter.

Detalle:

Cuando se ejecuta esta l√≠nea:

root = tk.Tk()


Est√°s creando una instancia de la ventana ra√≠z usando tkinter (abreviada como tk porque fue importada as√≠). Esta ventana es el contenedor principal de todos los elementos gr√°ficos (botones, entradas, etiquetas, etc.).

Luego, cuando haces:

app = StudentFuzzyGUI(root)


Est√°s creando un objeto StudentFuzzyGUI, que es tu interfaz de la aplicaci√≥n, y le est√°s pasando esa ventana ra√≠z (root) como argumento.

Esto le dice a la clase:

"Este es el espacio donde vas a construir tu interfaz gr√°fica".

¬øQu√© pasa dentro de la clase StudentFuzzyGUI con root?

En el constructor __init__, se guarda esa ventana en self.root:

self.root = root


Y luego, todo lo que se dibuja o configura (como tama√±o, fondo, widgets) se hace dentro de esa ventana.

Por ejemplo:

self.root.title("Evaluador Difuso de Estudiantes")
self.root.geometry("850x600")


Y cuando se a√±aden elementos gr√°ficos (widgets):

tk.Label(self.root, text="Ingrese su nombre:")
tk.Entry(self.root)


Todo se est√° montando sobre self.root.

Por √∫ltimo, esta l√≠nea es la que mantiene la ventana abierta y en funcionamiento:
root.mainloop()


Esto inicia el bucle de eventos de tkinter, que:

Mantiene la ventana visible.

Escucha eventos como clics o entradas de texto.

Ejecuta funciones cuando presionas botones, etc.

üîç Lo que puede ser dif√≠cil de entender para principiantes
Concepto	Explicaci√≥n breve
root = tk.Tk()	Crea la ventana principal (el "contenedor" de toda la interfaz).
StudentFuzzyGUI(root)	Le pasas esa ventana al constructor de tu clase para que la use como base para construir la GUI.
self.root.winfo_children()	Obtiene todos los widgets que est√°n dentro de la ventana, por si necesitas destruirlos o actualizarlos.
root.mainloop()	Inicia el bucle que mantiene viva la GUI hasta que el usuario la cierre.



1. ctrl.Antecedent y ctrl.Consequent

Estos crean variables difusas.

Antecedent es una variable de entrada (como asistencia o nota).

Consequent es la salida del sistema (como desempe√±o).

Ejemplo:

asistencia = ctrl.Antecedent(np.arange(0, 101, 1), 'asistencia')


Esto define que la variable asistencia tiene valores entre 0 y 100.

2. Funciones de membres√≠a con fuzz.trimf

Esta funci√≥n define c√≥mo un valor se "pertenece" a un conjunto difuso. Usamos un tri√°ngulo para representar las categor√≠as (bajo, medio, alto).

Ejemplo:

asistencia['baja'] = fuzz.trimf(asistencia.universe, [0, 0, 60])


Esto crea un conjunto difuso para asistencia baja, que va de 0 a 60%.

3. Reglas difusas con ctrl.Rule

Aqu√≠ definimos condiciones que combinan las variables de entrada para obtener un resultado de salida.

Ejemplo:

reglas = [
    ctrl.Rule(asistencia['baja'] & nota['bajo'], desempeno['deficiente']),
]


Si la asistencia es baja y la nota es baja, el desempe√±o es deficiente.

4. Simulaci√≥n de l√≥gica difusa con ControlSystemSimulation

Despu√©s de definir las reglas, simulamos el sistema con datos de entrada (asistencia y nota) para calcular la salida (desempe√±o).

Ejemplo:

evaluador = ctrl.ControlSystemSimulation(sistema_ctrl)
evaluador.input['asistencia'] = 80
evaluador.input['nota'] = 7
evaluador.compute()


Esto calcula el desempe√±o con una asistencia del 80% y una nota de 7.

5. winfo_children() y la actualizaci√≥n de la interfaz gr√°fica

Cuando creas una nueva pantalla o interfaz, eliminar√°s lo que hab√≠a antes con winfo_children() para evitar superposiciones.

Ejemplo:

for widget in self.root.winfo_children():
    widget.destroy()


Esto borra todos los elementos previos en la ventana antes de mostrar nuevos widgets.

6. root.mainloop()

Este es el bucle principal de la interfaz gr√°fica. Hace que la ventana siga abierta y responda a las interacciones del usuario (clics, teclas, etc.).

7. messagebox.showwarning() y messagebox.showerror()

Estos se usan para mostrar alertas emergentes con mensajes de advertencia o error cuando el usuario hace algo mal.

Ejemplo:

messagebox.showwarning("Advertencia", "Debe ingresar un nombre.")


Esto muestra una alerta si el usuario no ha ingresado un nombre.

Resumen final

Variables difusas (Antecedent, Consequent): Son las entradas y salidas del sistema.

Funciones de membres√≠a (fuzz.trimf): Definen c√≥mo un valor pertenece a una categor√≠a (bajo, medio, alto).

Reglas difusas (ctrl.Rule): Definen c√≥mo se relacionan las entradas con la salida.

Simulaci√≥n: Usamos los valores de entrada para calcular la salida.

tkinter: Usamos root.mainloop() para mantener la ventana abierta y que responda a interacciones.



‚úÖ ¬øQu√© muestra el √°rea de texto al evaluar?

Cuando el usuario ingresa una asistencia y una nota, y presiona ‚ÄúEvaluar‚Äù, el sistema muestra cuatro secciones principales en el √°rea de texto:

üß© 1. FUSIFICACI√ìN: ------ FUSIFICACI√ìN ------
Asistencia 'baja': 0.00
Asistencia 'media': 0.65
Asistencia 'alta': 0.30
Nota 'bajo': 0.00
Nota 'medio': 0.75
Nota 'alto': 0.25
¬øQu√© significa?

Aqu√≠ se muestra el grado de pertenencia del valor ingresado a cada conjunto difuso (funci√≥n de membres√≠a).

Por ejemplo, si pones Asistencia = 75, esa asistencia podr√≠a pertenecer:

un 65% al conjunto "media",

un 30% al conjunto "alta",

y 0% al conjunto "baja".

Igual para la nota, donde por ejemplo una nota de 7 pertenece un 75% al conjunto "medio" y un 25% al conjunto "alto".

Esto es la fuzzificaci√≥n: convertir un n√∫mero exacto (crisp) en grados difusos.

‚öñÔ∏è 2. REGLAS APLICADAS
------ REGLAS APLICADAS ------
Regla 1: SI asistencia['baja'] AND nota['bajo'] ‚Üí desempe√±o['deficiente']
Regla 2: SI asistencia['media'] AND nota['medio'] ‚Üí desempe√±o['aceptable']
...

üîç ¬øQu√© significa?

Aqu√≠ se listan todas las reglas definidas en el sistema difuso.

Cada regla es del tipo:

‚ÄúSi asistencia es baja y nota es baja, entonces desempe√±o es deficiente‚Äù.

Aunque aqu√≠ no te dice cu√°les se activaron, internamente el sistema activa solo aquellas cuyo grado de activaci√≥n > 0, dependiendo de la entrada.

üéØ 3. DESFUSIFICACI√ìN

------ DESFUSIFICACI√ìN ------
Resultado final (desempe√±o): 64.35 / 100

üîç ¬øQu√© significa?

Despu√©s de aplicar las reglas activadas, el sistema tiene un conjunto de salidas difusas (por ejemplo: desempe√±o es 40% "aceptable" y 60% "excelente").

La desfuzzificaci√≥n convierte esa salida difusa en un valor num√©rico exacto.

En este ejemplo, el resultado de desempe√±o fue 64.35 sobre 100.

üèÅ 4. EVALUACI√ìN FINAL
------ EVALUACI√ìN FINAL ------
Estado del estudiante: RENDIMIENTO ACEPTABLE - Buen trabajo, sigue as√≠.

üîç ¬øQu√© significa?

El sistema interpreta el resultado num√©rico en palabras:

< 50: rendimiento deficiente

50 a <75: aceptable

‚â•75: excelente

Esto es solo una clasificaci√≥n adicional, basada en rangos definidos en el c√≥digo.

üîÅ Ejemplo completo

Sup√≥n que ingresas:

Asistencia = 75

Nota = 7

Ver√°s algo como:
------ FUSIFICACI√ìN ------
Asistencia 'baja': 0.00
Asistencia 'media': 0.60
Asistencia 'alta': 0.40
Nota 'bajo': 0.00
Nota 'medio': 0.50
Nota 'alto': 0.50

------ REGLAS APLICADAS ------
Regla 1: SI asistencia['baja'] AND nota['bajo'] ‚Üí desempe√±o['deficiente']
Regla 2: SI asistencia['media'] AND nota['medio'] ‚Üí desempe√±o['aceptable']
Regla 3: SI asistencia['alta'] AND nota['alto'] ‚Üí desempe√±o['excelente']
...

------ DESFUSIFICACI√ìN ------
Resultado final (desempe√±o): 71.2 / 100

------ EVALUACI√ìN FINAL ------
Estado del estudiante: RENDIMIENTO ACEPTABLE - Buen trabajo, sigue as√≠.



üß† En resumen:

El √°rea de texto te muestra todo el proceso l√≥gico difuso paso a paso:

Cu√°nto pertenecen las entradas a los conjuntos (fuzzificaci√≥n)

Qu√© reglas se est√°n evaluando

Qu√© resultado num√©rico final se obtuvo

C√≥mo se interpreta ese resultado en palabras






üìö Contexto del sistema

Este sistema eval√∫a el desempe√±o acad√©mico de un estudiante bas√°ndose en dos factores:

Asistencia al curso (de 0 a 100%)

Nota promedio obtenida (de 0 a 10)

La salida del sistema es el desempe√±o del estudiante (tambi√©n de 0 a 100), clasificado como:

deficiente

aceptable

excelente
üîÑ Reglas difusas definidas
‚úÖ Regla 1:ctrl.Rule(asistencia['baja'] & nota['bajo'], desempeno['deficiente'])


üß† Significado:

"Si el estudiante tiene baja asistencia y baja nota, entonces su desempe√±o es deficiente."

Esta es una regla l√≥gica b√°sica, porque ambas entradas son malas.

Si un estudiante no asiste y adem√°s saca malas notas, es razonable asumir que su rendimiento es bajo.



‚úÖ Regla 2:
ctrl.Rule(asistencia['media'] & nota['medio'], desempeno['aceptable'])


üß† Significado:

"Si el estudiante tiene asistencia media y nota media, entonces su desempe√±o es aceptable."

Aqu√≠ ambas entradas son intermedias, por lo que el sistema concluye que su rendimiento tambi√©n es medio.

Esto es coherente y equilibrado.


‚úÖ Regla 3:
ctrl.Rule(asistencia['alta'] & nota['alto'], desempeno['excelente'])

üß† Significado:

"Si el estudiante tiene asistencia alta y nota alta, entonces su desempe√±o es excelente."

Esta es una regla positiva, donde todo va bien.

Alta participaci√≥n y buenas calificaciones = alto rendimiento.

‚úÖ Regla 4:
ctrl.Rule(asistencia['media'] & nota['alto'], desempeno['aceptable'])

üß† Significado:

"Si el estudiante tiene asistencia media pero nota alta, entonces su desempe√±o es aceptable."

Aqu√≠ hay un buen rendimiento acad√©mico, pero la asistencia no es ideal.

El sistema es un poco conservador: no le da "excelente" porque su participaci√≥n no es constante.

Interpreta que se desempe√±a bien, pero puede mejorar asistiendo m√°s.

‚úÖ Regla 5:

ctrl.Rule(asistencia['alta'] & nota['medio'], desempeno['aceptable'])


üß† Significado:

"Si el estudiante tiene alta asistencia pero nota media, entonces su desempe√±o es aceptable."

El estudiante es constante en la asistencia, pero sus notas son promedio.

Esta regla reconoce el esfuerzo (asistencia alta) pero tambi√©n que necesita mejorar el rendimiento acad√©mico.


‚úÖ Regla 6:
ctrl.Rule(asistencia['baja'] & nota['alto'], desempeno['aceptable'])


üß† Significado:

"Si el estudiante tiene baja asistencia pero nota alta, entonces su desempe√±o es aceptable."

Este caso representa a un estudiante que no va mucho a clase, pero aun as√≠ rinde bien.

El sistema reconoce su rendimiento, pero penaliza un poco la baja participaci√≥n.

Por eso no da "excelente", sino "aceptable".

‚úÖ Regla 7:

ctrl.Rule(asistencia['alta'] & nota['bajo'], desempeno['deficiente'])



| Asistencia | Nota  | Resultado esperado | L√≥gica detr√°s                                                            |
| ---------- | ----- | ------------------ | ------------------------------------------------------------------------ |
| Baja       | Baja  | Deficiente         | Nada va bien                                                             |
| Media      | Media | Aceptable          | Rendimiento promedio                                                     |
| Alta       | Alta  | Excelente          | Excelente comportamiento y rendimiento                                   |
| Media      | Alta  | Aceptable          | Buen rendimiento, pero le falta m√°s compromiso                           |
| Alta       | Media | Aceptable          | Se esfuerza y participa, pero necesita mejorar el rendimiento            |
| Baja       | Alta  | Aceptable          | Buen rendimiento pese a poca asistencia, pero eso afecta el juicio final |
| Alta       | Baja  | Deficiente         | Participa, pero no entiende o no rinde; requiere intervenci√≥n acad√©mica  |








Mensajes de error si se pone numero superior:
import numpy as np
import skfuzzy as fuzz
import skfuzzy.control as ctrl
import tkinter as tk
from tkinter import messagebox

# SISTEMA DIFUSO SKFUZZY

# 1. Definici√≥n de variables 
asistencia = ctrl.Antecedent(np.arange(0, 101, 1), 'asistencia')
nota = ctrl.Antecedent(np.arange(0, 11, 0.1), 'nota')
desempeno = ctrl.Consequent(np.arange(0, 101, 1), 'desempe√±o')

# 2. Conjuntos difusos
asistencia['baja'] = fuzz.trimf(asistencia.universe, [0, 0, 60])
asistencia['media'] = fuzz.trimf(asistencia.universe, [40, 70, 90])
asistencia['alta'] = fuzz.trimf(asistencia.universe, [60, 100, 100])

nota['bajo'] = fuzz.trimf(nota.universe, [0, 0, 6])
nota['medio'] = fuzz.trimf(nota.universe, [4, 6, 8])
nota['alto'] = fuzz.trimf(nota.universe, [6, 10, 10])

desempeno['deficiente'] = fuzz.trimf(desempeno.universe, [0, 30, 50])
desempeno['aceptable'] = fuzz.trimf(desempeno.universe, [40, 60, 75])
desempeno['excelente'] = fuzz.trimf(desempeno.universe, [70, 90, 100])

# 3. Reglas difusas
reglas = [
    ctrl.Rule(asistencia['baja'] & nota['bajo'], desempeno['deficiente']),
    ctrl.Rule(asistencia['media'] & nota['medio'], desempeno['aceptable']),
    ctrl.Rule(asistencia['alta'] & nota['alto'], desempeno['excelente']),
    ctrl.Rule(asistencia['media'] & nota['alto'], desempeno['aceptable']),
    ctrl.Rule(asistencia['alta'] & nota['medio'], desempeno['aceptable']),
    ctrl.Rule(asistencia['baja'] & nota['alto'], desempeno['aceptable']),
    ctrl.Rule(asistencia['alta'] & nota['bajo'], desempeno['deficiente'])
]

sistema_ctrl = ctrl.ControlSystem(reglas)
evaluador = ctrl.ControlSystemSimulation(sistema_ctrl)

# INTERFAZ GR√ÅFICA

class StudentFuzzyGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("Evaluador Difuso de Estudiantes")
        self.root.geometry("850x600")
        self.root.configure(bg="#e0f7fa")
        self.username = ""
        self.create_login_screen()

    def create_login_screen(self):
        for widget in self.root.winfo_children():
            widget.destroy()
        tk.Label(self.root, text="Sistema difuso de evaluaci√≥n acad√©mica", font=("Helvetica", 18), bg="#e0f7fa").pack(pady=40)
        tk.Label(self.root, text="Ingrese su nombre:", font=("Helvetica", 14), bg="#e0f7fa").pack()
        self.username_entry = tk.Entry(self.root, font=("Helvetica", 14))
        self.username_entry.pack(pady=10)
        tk.Button(self.root, text="Ingresar", font=("Helvetica", 14), command=self.start_system, bg="#00796b", fg="white").pack(pady=20)

    def start_system(self):
        name = self.username_entry.get().strip()
        if not name:
            messagebox.showwarning("Advertencia", "Debe ingresar un nombre.")
            return
        self.username = name
        self.create_main_screen()

    def create_main_screen(self):
        for widget in self.root.winfo_children():
            widget.destroy()
        tk.Label(self.root, text=f"Hola, {self.username}", font=("Helvetica", 16, "bold"), bg="#e0f7fa").pack(pady=10)
        tk.Label(self.root, text="Ingrese el porcentaje de asistencia (%):", font=("Helvetica", 14), bg="#e0f7fa").pack()
        self.att_entry = tk.Entry(self.root, font=("Helvetica", 14))
        self.att_entry.pack(pady=5)
        tk.Label(self.root, text="Ingrese el promedio de notas (0-10):", font=("Helvetica", 14), bg="#e0f7fa").pack()
        self.grade_entry = tk.Entry(self.root, font=("Helvetica", 14))
        self.grade_entry.pack(pady=5)
        tk.Button(self.root, text="Evaluar", font=("Helvetica", 14), command=self.process_input, bg="#0288d1", fg="white").pack(pady=20)
        self.result_text = tk.Text(self.root, height=20, font=("Courier", 11), width=95, bg="#ffffff", wrap="word")
        self.result_text.pack(pady=10)

    def process_input(self):
        try:
            att = float(self.att_entry.get())
            grade = float(self.grade_entry.get())
            
            # VALIDACIONES agregadas aqu√≠ üëá
            if att < 0 or att > 100:
                messagebox.showerror("Error", "La asistencia debe estar entre 0 y 100.")
                return
            if grade < 0 or grade > 10:
                messagebox.showerror("Error", "La nota debe estar entre 0 y 10.")
                return

        except ValueError:
            messagebox.showerror("Error", "Ingrese valores num√©ricos v√°lidos.")
            return

        # Evaluaci√≥n con l√≥gica difusa
        evaluador.input['asistencia'] = att
        evaluador.input['nota'] = grade
        evaluador.compute()
        resultado = evaluador.output['desempe√±o']

        # Mostrar resultados
        self.result_text.delete(1.0, tk.END)
        self.result_text.insert(tk.END, "------ FUSIFICACI√ìN ------\n")
        for name, mf in asistencia.terms.items():
            val = fuzz.interp_membership(asistencia.universe, mf.mf, att)
            self.result_text.insert(tk.END, f"Asistencia '{name}': {val:.2f}\n")
        for name, mf in nota.terms.items():
            val = fuzz.interp_membership(nota.universe, mf.mf, grade)
            self.result_text.insert(tk.END, f"Nota '{name}': {val:.2f}\n")

        self.result_text.insert(tk.END, "\n------ REGLAS APLICADAS ------\n")
        for idx, rule in enumerate(sistema_ctrl.rules):
            a = rule.antecedent
            self.result_text.insert(tk.END, f"Regla {idx+1}: SI {a} ‚Üí {rule.consequent}\n")

        self.result_text.insert(tk.END, "\n------ DESFUSIFICACI√ìN ------\n")
        self.result_text.insert(tk.END, f"Resultado final (desempe√±o): {resultado:.2f} / 100\n")

        self.result_text.insert(tk.END, "\n------ EVALUACI√ìN FINAL ------\n")
        if resultado < 50:
            estado = "RENDIMIENTO DEFICIENTE - Se recomienda reforzar el estudio y mejorar la asistencia."
        elif resultado < 75:
            estado = "RENDIMIENTO ACEPTABLE - Buen trabajo, sigue as√≠."
        else:
            estado = "RENDIMIENTO EXCELENTE - ¬°Felicidades!"

        self.result_text.insert(tk.END, f"Estado del estudiante: {estado}\n")


# EJECUCI√ìN DEL SISTEMA
if __name__ == "__main__":
    root = tk.Tk()
    app = StudentFuzzyGUI(root)
    root.mainloop()




OTRAS COSAS AGREGADAS (NO IMPORTANTES)
    def process_input(self):
        try:
            att = float(self.att_entry.get())
            grade = float(self.grade_entry.get())
            
            # VALIDACIONES agregadas aqu√≠ üëá
            if att < 0 or att > 100:
                messagebox.showerror("Error", "La asistencia debe estar entre 0 y 100.")
                return
            if grade < 0 or grade > 10:
                messagebox.showerror("Error", "La nota debe estar entre 0 y 10.")
                return

        except ValueError:
            messagebox.showerror("Error", "Ingrese valores num√©ricos v√°lidos.")
            return

        # Evaluaci√≥n con l√≥gica difusa
        evaluador.input['asistencia'] = att
        evaluador.input['nota'] = grade
        evaluador.compute()
        resultado = evaluador.output['desempe√±o']

        # Mostrar resultados
        self.result_text.delete(1.0, tk.END)
        self.result_text.insert(tk.END, "------ FUSIFICACI√ìN ------\n")
        for name, mf in asistencia.terms.items():
            val = fuzz.interp_membership(asistencia.universe, mf.mf, att)
            self.result_text.insert(tk.END, f"Asistencia '{name}': {val:.2f}\n")
        for name, mf in nota.terms.items():
            val = fuzz.interp_membership(nota.universe, mf.mf, grade)
            self.result_text.insert(tk.END, f"Nota '{name}': {val:.2f}\n")

        self.result_text.insert(tk.END, "\n------ REGLAS APLICADAS ------\n")
        for idx, rule in enumerate(sistema_ctrl.rules):
            a = rule.antecedent
            self.result_text.insert(tk.END, f"Regla {idx+1}: SI {a} ‚Üí {rule.consequent}\n")

        self.result_text.insert(tk.END, "\n------ DESFUSIFICACI√ìN ------\n")
        self.result_text.insert(tk.END, f"Resultado final (desempe√±o): {resultado:.2f} / 100\n")

        self.result_text.insert(tk.END, "\n------ EVALUACI√ìN FINAL ------\n")
        if resultado < 50:
            estado = "RENDIMIENTO DEFICIENTE - Se recomienda reforzar el estudio y mejorar la asistencia."
        elif resultado < 75:
            estado = "RENDIMIENTO ACEPTABLE - Buen trabajo, sigue as√≠."
        else:
            estado = "RENDIMIENTO EXCELENTE - ¬°Felicidades!"
        self.result_text.insert(tk.END, f"Estado del estudiante: {estado}\n")

        # üîç AN√ÅLISIS ADICIONAL AUTOM√ÅTICO
        self.result_text.insert(tk.END, "\n------ AN√ÅLISIS ADICIONAL ------\n")

        fortalezas = []
        mejoras = []

        # An√°lisis de asistencia
        if att >= 85:
            fortalezas.append("Asistencia")
        elif att < 60:
            mejoras.append("Asistencia")

        # An√°lisis de nota
        if grade >= 8.5:
            fortalezas.append("Nota")
        elif grade < 6:
            mejoras.append("Nota")

        # Mostrar an√°lisis
        self.result_text.insert(tk.END, f"Fortalezas detectadas: {', '.join(fortalezas) if fortalezas else 'Ninguna'}\n")
        self.result_text.insert(tk.END, f"√Åreas de mejora: {', '.join(mejoras) if mejoras else 'Ninguna'}\n")
