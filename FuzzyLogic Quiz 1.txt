. Importación de librerías

numpy: para manejar arreglos numéricos.

skfuzzy y skfuzzy.control: para crear y manejar lógica difusa.

tkinter: para la interfaz gráfica.

messagebox: para mostrar alertas y mensajes emergentes.

2. Definición de variables difusas

Se crean tres variables:

Entrada (Antecedentes):

asistencia: porcentaje de asistencia (0 a 100).

nota: promedio de notas (0 a 10).

Salida (Consecuente):

desempeno: evaluación del desempeño (0 a 100).

3. Definición de conjuntos difusos (funciones de membresía)

Para cada variable, se definen funciones de membresía triangulares que indican qué tan "bajo", "medio", o "alto" es un valor.

Para asistencia:

baja: 0 a 60%

media: 40 a 90%

alta: 60 a 100%

Para nota:

bajo: 0 a 6

medio: 4 a 8

alto: 6 a 10

Para desempeño:

deficiente: 0 a 50

aceptable: 40 a 75

excelente: 70 a 100

Estas funciones permiten que un valor no pertenezca solo a un conjunto, sino parcialmente a varios (por ejemplo, una asistencia del 65% podría ser parte de "media" y "alta").

4. Definición de reglas difusas

Se crean reglas para evaluar el desempeño en función de la asistencia y la nota, por ejemplo:

Si la asistencia es baja y la nota es baja, entonces el desempeño es deficiente.

Si la asistencia es alta y la nota es alta, el desempeño es excelente.

Y otras combinaciones que cubren diferentes casos.

5. Creación del sistema y simulador de lógica difusa

Se crea un sistema de control basado en las reglas y un simulador para evaluar datos de entrada.

6. Interfaz gráfica (con Tkinter)

Se construye una ventana donde:

Primero pide el nombre del usuario (login simple).

Luego pide ingresar porcentaje de asistencia y nota promedio.

Al presionar "Evaluar", se ejecuta el sistema difuso con esos datos.

Muestra:

Grados de pertenencia (fuzzificación) para asistencia y nota.

Reglas aplicadas.

Resultado difuso (desempeño).

Evaluación final en texto (deficiente, aceptable, excelente).

7. Ejecución principal

Se crea la ventana y se inicia la aplicación gráfica.




import numpy as np
import skfuzzy as fuzz
import skfuzzy.control as ctrl
import tkinter as tk
from tkinter import messagebox

# SISTEMA DIFUSO SKFUZZY

# 1. Definición de variables de entrada y salida
asistencia = ctrl.Antecedent(np.arange(0, 101, 1), 'asistencia')  # porcentaje 0-100
nota = ctrl.Antecedent(np.arange(0, 11, 0.1), 'nota')             # nota 0-10
desempeno = ctrl.Consequent(np.arange(0, 101, 1), 'desempeño')    # desempeño 0-100

# 2. Definición de conjuntos difusos con funciones de membresía triangulares
asistencia['baja'] = fuzz.trimf(asistencia.universe, [0, 0, 60])
asistencia['media'] = fuzz.trimf(asistencia.universe, [40, 70, 90])
asistencia['alta'] = fuzz.trimf(asistencia.universe, [60, 100, 100])

nota['bajo'] = fuzz.trimf(nota.universe, [0, 0, 6])
nota['medio'] = fuzz.trimf(nota.universe, [4, 6, 8])
nota['alto'] = fuzz.trimf(nota.universe, [6, 10, 10])

desempeno['deficiente'] = fuzz.trimf(desempeno.universe, [0, 30, 50])
desempeno['aceptable'] = fuzz.trimf(desempeno.universe, [40, 60, 75])
desempeno['excelente'] = fuzz.trimf(desempeno.universe, [70, 90, 100])

# 3. Reglas difusas que relacionan asistencia y nota con el desempeño
reglas = [
    ctrl.Rule(asistencia['baja'] & nota['bajo'], desempeno['deficiente']),
    ctrl.Rule(asistencia['media'] & nota['medio'], desempeno['aceptable']),
    ctrl.Rule(asistencia['alta'] & nota['alto'], desempeno['excelente']),
    ctrl.Rule(asistencia['media'] & nota['alto'], desempeno['aceptable']),
    ctrl.Rule(asistencia['alta'] & nota['medio'], desempeno['aceptable']),
    ctrl.Rule(asistencia['baja'] & nota['alto'], desempeno['aceptable']),
    ctrl.Rule(asistencia['alta'] & nota['bajo'], desempeno['deficiente'])
]

# 4. Creación del sistema difuso y simulador
sistema_ctrl = ctrl.ControlSystem(reglas)
evaluador = ctrl.ControlSystemSimulation(sistema_ctrl)

# 5. Interfaz gráfica con Tkinter para interacción con el usuario
class StudentFuzzyGUI:
    def __init__(self, root):
        # Inicialización de la ventana principal
        self.root = root
        self.root.title("Evaluador Difuso de Estudiantes")
        self.root.geometry("850x600")
        self.root.configure(bg="#e0f7fa")
        self.username = ""
        self.create_login_screen()

    def create_login_screen(self):
        # Pantalla para ingresar el nombre del usuario
        for widget in self.root.winfo_children():
            widget.destroy()
        tk.Label(self.root, text="Sistema difuso de evaluación académica", font=("Helvetica", 18), bg="#e0f7fa").pack(pady=40)
        tk.Label(self.root, text="Ingrese su nombre:", font=("Helvetica", 14), bg="#e0f7fa").pack()
        self.username_entry = tk.Entry(self.root, font=("Helvetica", 14))
        self.username_entry.pack(pady=10)
        tk.Button(self.root, text="Ingresar", font=("Helvetica", 14), command=self.start_system, bg="#00796b", fg="white").pack(pady=20)

    def start_system(self):
        # Valida el nombre y pasa a la pantalla principal
        name = self.username_entry.get().strip()
        if not name:
            messagebox.showwarning("Advertencia", "Debe ingresar un nombre.")
            return
        self.username = name
        self.create_main_screen()

    def create_main_screen(self):
        # Pantalla principal para ingresar datos y evaluar
        for widget in self.root.winfo_children():
            widget.destroy()
        tk.Label(self.root, text=f"Hola, {self.username}", font=("Helvetica", 16, "bold"), bg="#e0f7fa").pack(pady=10)
        tk.Label(self.root, text="Ingrese el porcentaje de asistencia (%):", font=("Helvetica", 14), bg="#e0f7fa").pack()
        self.att_entry = tk.Entry(self.root, font=("Helvetica", 14))
        self.att_entry.pack(pady=5)
        tk.Label(self.root, text="Ingrese el promedio de notas (0-10):", font=("Helvetica", 14), bg="#e0f7fa").pack()
        self.grade_entry = tk.Entry(self.root, font=("Helvetica", 14))
        self.grade_entry.pack(pady=5)
        tk.Button(self.root, text="Evaluar", font=("Helvetica", 14), command=self.process_input, bg="#0288d1", fg="white").pack(pady=20)
        self.result_text = tk.Text(self.root, height=20, font=("Courier", 11), width=95, bg="#ffffff", wrap="word")
        self.result_text.pack(pady=10)

    def process_input(self):
        # Procesa los datos ingresados y evalúa con lógica difusa
        try:
            att = float(self.att_entry.get())
            grade = float(self.grade_entry.get())
            if not (0 <= att <= 100) or not (0 <= grade <= 10):
                raise ValueError
        except ValueError:
            messagebox.showerror("Error", "Ingrese valores válidos (Asistencia 0-100, Nota 0-10).")
            return

        # Realiza la evaluación con el sistema difuso
        evaluador.input['asistencia'] = att
        evaluador.input['nota'] = grade
        evaluador.compute()
        resultado = evaluador.output['desempeño']

        # Mostrar resultados en la interfaz
        self.result_text.delete(1.0, tk.END)
        self.result_text.insert(tk.END, "------ FUSIFICACIÓN ------\n")
        # Mostrar grado de pertenencia para asistencia
        for name, mf in asistencia.terms.items():
            val = fuzz.interp_membership(asistencia.universe, mf.mf, att)
            self.result_text.insert(tk.END, f"Asistencia '{name}': {val:.2f}\n")
        # Mostrar grado de pertenencia para nota
        for name, mf in nota.terms.items():
            val = fuzz.interp_membership(nota.universe, mf.mf, grade)
            self.result_text.insert(tk.END, f"Nota '{name}': {val:.2f}\n")

        self.result_text.insert(tk.END, "\n------ REGLAS APLICADAS ------\n")
        for idx, rule in enumerate(sistema_ctrl.rules):
            a = rule.antecedent
            self.result_text.insert(tk.END, f"Regla {idx+1}: SI {a} → {rule.consequent}\n")

        self.result_text.insert(tk.END, "\n------ DESFUSIFICACIÓN ------\n")
        self.result_text.insert(tk.END, f"Resultado final (desempeño): {resultado:.2f} / 100\n")

        # Evaluación final basada en el resultado
        self.result_text.insert(tk.END, "\n------ EVALUACIÓN FINAL ------\n")
        if resultado < 50:
            estado = "RENDIMIENTO DEFICIENTE - Se recomienda reforzar el estudio y mejorar la asistencia."
        elif resultado < 75:
            estado = "RENDIMIENTO ACEPTABLE - Buen trabajo, sigue así."
        else:
            estado = "RENDIMIENTO EXCELENTE - ¡Felicidades!"

        self.result_text.insert(tk.END, f"Estado del estudiante: {estado}\n")


# EJECUCIÓN DEL SISTEMA: Inicializa la interfaz gráfica y el sistema
if __name__ == "__main__":
    root = tk.Tk()
    app = StudentFuzzyGUI(root)
    root.mainloop()

✅ ¿Qué hace root en app = StudentFuzzyGUI(root)?

root es la ventana principal de la interfaz gráfica de usuario (GUI) creada con tkinter.

Detalle:

Cuando se ejecuta esta línea:

root = tk.Tk()


Estás creando una instancia de la ventana raíz usando tkinter (abreviada como tk porque fue importada así). Esta ventana es el contenedor principal de todos los elementos gráficos (botones, entradas, etiquetas, etc.).

Luego, cuando haces:

app = StudentFuzzyGUI(root)


Estás creando un objeto StudentFuzzyGUI, que es tu interfaz de la aplicación, y le estás pasando esa ventana raíz (root) como argumento.

Esto le dice a la clase:

"Este es el espacio donde vas a construir tu interfaz gráfica".

¿Qué pasa dentro de la clase StudentFuzzyGUI con root?

En el constructor __init__, se guarda esa ventana en self.root:

self.root = root


Y luego, todo lo que se dibuja o configura (como tamaño, fondo, widgets) se hace dentro de esa ventana.

Por ejemplo:

self.root.title("Evaluador Difuso de Estudiantes")
self.root.geometry("850x600")


Y cuando se añaden elementos gráficos (widgets):

tk.Label(self.root, text="Ingrese su nombre:")
tk.Entry(self.root)


Todo se está montando sobre self.root.

Por último, esta línea es la que mantiene la ventana abierta y en funcionamiento:
root.mainloop()


Esto inicia el bucle de eventos de tkinter, que:

Mantiene la ventana visible.

Escucha eventos como clics o entradas de texto.

Ejecuta funciones cuando presionas botones, etc.

🔍 Lo que puede ser difícil de entender para principiantes
Concepto	Explicación breve
root = tk.Tk()	Crea la ventana principal (el "contenedor" de toda la interfaz).
StudentFuzzyGUI(root)	Le pasas esa ventana al constructor de tu clase para que la use como base para construir la GUI.
self.root.winfo_children()	Obtiene todos los widgets que están dentro de la ventana, por si necesitas destruirlos o actualizarlos.
root.mainloop()	Inicia el bucle que mantiene viva la GUI hasta que el usuario la cierre.



1. ctrl.Antecedent y ctrl.Consequent

Estos crean variables difusas.

Antecedent es una variable de entrada (como asistencia o nota).

Consequent es la salida del sistema (como desempeño).

Ejemplo:

asistencia = ctrl.Antecedent(np.arange(0, 101, 1), 'asistencia')


Esto define que la variable asistencia tiene valores entre 0 y 100.

2. Funciones de membresía con fuzz.trimf

Esta función define cómo un valor se "pertenece" a un conjunto difuso. Usamos un triángulo para representar las categorías (bajo, medio, alto).

Ejemplo:

asistencia['baja'] = fuzz.trimf(asistencia.universe, [0, 0, 60])


Esto crea un conjunto difuso para asistencia baja, que va de 0 a 60%.

3. Reglas difusas con ctrl.Rule

Aquí definimos condiciones que combinan las variables de entrada para obtener un resultado de salida.

Ejemplo:

reglas = [
    ctrl.Rule(asistencia['baja'] & nota['bajo'], desempeno['deficiente']),
]


Si la asistencia es baja y la nota es baja, el desempeño es deficiente.

4. Simulación de lógica difusa con ControlSystemSimulation

Después de definir las reglas, simulamos el sistema con datos de entrada (asistencia y nota) para calcular la salida (desempeño).

Ejemplo:

evaluador = ctrl.ControlSystemSimulation(sistema_ctrl)
evaluador.input['asistencia'] = 80
evaluador.input['nota'] = 7
evaluador.compute()


Esto calcula el desempeño con una asistencia del 80% y una nota de 7.

5. winfo_children() y la actualización de la interfaz gráfica

Cuando creas una nueva pantalla o interfaz, eliminarás lo que había antes con winfo_children() para evitar superposiciones.

Ejemplo:

for widget in self.root.winfo_children():
    widget.destroy()


Esto borra todos los elementos previos en la ventana antes de mostrar nuevos widgets.

6. root.mainloop()

Este es el bucle principal de la interfaz gráfica. Hace que la ventana siga abierta y responda a las interacciones del usuario (clics, teclas, etc.).

7. messagebox.showwarning() y messagebox.showerror()

Estos se usan para mostrar alertas emergentes con mensajes de advertencia o error cuando el usuario hace algo mal.

Ejemplo:

messagebox.showwarning("Advertencia", "Debe ingresar un nombre.")


Esto muestra una alerta si el usuario no ha ingresado un nombre.

Resumen final

Variables difusas (Antecedent, Consequent): Son las entradas y salidas del sistema.

Funciones de membresía (fuzz.trimf): Definen cómo un valor pertenece a una categoría (bajo, medio, alto).

Reglas difusas (ctrl.Rule): Definen cómo se relacionan las entradas con la salida.

Simulación: Usamos los valores de entrada para calcular la salida.

tkinter: Usamos root.mainloop() para mantener la ventana abierta y que responda a interacciones.



✅ ¿Qué muestra el área de texto al evaluar?

Cuando el usuario ingresa una asistencia y una nota, y presiona “Evaluar”, el sistema muestra cuatro secciones principales en el área de texto:

🧩 1. FUSIFICACIÓN: ------ FUSIFICACIÓN ------
Asistencia 'baja': 0.00
Asistencia 'media': 0.65
Asistencia 'alta': 0.30
Nota 'bajo': 0.00
Nota 'medio': 0.75
Nota 'alto': 0.25
¿Qué significa?

Aquí se muestra el grado de pertenencia del valor ingresado a cada conjunto difuso (función de membresía).

Por ejemplo, si pones Asistencia = 75, esa asistencia podría pertenecer:

un 65% al conjunto "media",

un 30% al conjunto "alta",

y 0% al conjunto "baja".

Igual para la nota, donde por ejemplo una nota de 7 pertenece un 75% al conjunto "medio" y un 25% al conjunto "alto".

Esto es la fuzzificación: convertir un número exacto (crisp) en grados difusos.

⚖️ 2. REGLAS APLICADAS
------ REGLAS APLICADAS ------
Regla 1: SI asistencia['baja'] AND nota['bajo'] → desempeño['deficiente']
Regla 2: SI asistencia['media'] AND nota['medio'] → desempeño['aceptable']
...

🔍 ¿Qué significa?

Aquí se listan todas las reglas definidas en el sistema difuso.

Cada regla es del tipo:

“Si asistencia es baja y nota es baja, entonces desempeño es deficiente”.

Aunque aquí no te dice cuáles se activaron, internamente el sistema activa solo aquellas cuyo grado de activación > 0, dependiendo de la entrada.

🎯 3. DESFUSIFICACIÓN

------ DESFUSIFICACIÓN ------
Resultado final (desempeño): 64.35 / 100

🔍 ¿Qué significa?

Después de aplicar las reglas activadas, el sistema tiene un conjunto de salidas difusas (por ejemplo: desempeño es 40% "aceptable" y 60% "excelente").

La desfuzzificación convierte esa salida difusa en un valor numérico exacto.

En este ejemplo, el resultado de desempeño fue 64.35 sobre 100.

🏁 4. EVALUACIÓN FINAL
------ EVALUACIÓN FINAL ------
Estado del estudiante: RENDIMIENTO ACEPTABLE - Buen trabajo, sigue así.

🔍 ¿Qué significa?

El sistema interpreta el resultado numérico en palabras:

< 50: rendimiento deficiente

50 a <75: aceptable

≥75: excelente

Esto es solo una clasificación adicional, basada en rangos definidos en el código.

🔁 Ejemplo completo

Supón que ingresas:

Asistencia = 75

Nota = 7

Verás algo como:
------ FUSIFICACIÓN ------
Asistencia 'baja': 0.00
Asistencia 'media': 0.60
Asistencia 'alta': 0.40
Nota 'bajo': 0.00
Nota 'medio': 0.50
Nota 'alto': 0.50

------ REGLAS APLICADAS ------
Regla 1: SI asistencia['baja'] AND nota['bajo'] → desempeño['deficiente']
Regla 2: SI asistencia['media'] AND nota['medio'] → desempeño['aceptable']
Regla 3: SI asistencia['alta'] AND nota['alto'] → desempeño['excelente']
...

------ DESFUSIFICACIÓN ------
Resultado final (desempeño): 71.2 / 100

------ EVALUACIÓN FINAL ------
Estado del estudiante: RENDIMIENTO ACEPTABLE - Buen trabajo, sigue así.



🧠 En resumen:

El área de texto te muestra todo el proceso lógico difuso paso a paso:

Cuánto pertenecen las entradas a los conjuntos (fuzzificación)

Qué reglas se están evaluando

Qué resultado numérico final se obtuvo

Cómo se interpreta ese resultado en palabras






📚 Contexto del sistema

Este sistema evalúa el desempeño académico de un estudiante basándose en dos factores:

Asistencia al curso (de 0 a 100%)

Nota promedio obtenida (de 0 a 10)

La salida del sistema es el desempeño del estudiante (también de 0 a 100), clasificado como:

deficiente

aceptable

excelente
🔄 Reglas difusas definidas
✅ Regla 1:ctrl.Rule(asistencia['baja'] & nota['bajo'], desempeno['deficiente'])


🧠 Significado:

"Si el estudiante tiene baja asistencia y baja nota, entonces su desempeño es deficiente."

Esta es una regla lógica básica, porque ambas entradas son malas.

Si un estudiante no asiste y además saca malas notas, es razonable asumir que su rendimiento es bajo.



✅ Regla 2:
ctrl.Rule(asistencia['media'] & nota['medio'], desempeno['aceptable'])


🧠 Significado:

"Si el estudiante tiene asistencia media y nota media, entonces su desempeño es aceptable."

Aquí ambas entradas son intermedias, por lo que el sistema concluye que su rendimiento también es medio.

Esto es coherente y equilibrado.


✅ Regla 3:
ctrl.Rule(asistencia['alta'] & nota['alto'], desempeno['excelente'])

🧠 Significado:

"Si el estudiante tiene asistencia alta y nota alta, entonces su desempeño es excelente."

Esta es una regla positiva, donde todo va bien.

Alta participación y buenas calificaciones = alto rendimiento.

✅ Regla 4:
ctrl.Rule(asistencia['media'] & nota['alto'], desempeno['aceptable'])

🧠 Significado:

"Si el estudiante tiene asistencia media pero nota alta, entonces su desempeño es aceptable."

Aquí hay un buen rendimiento académico, pero la asistencia no es ideal.

El sistema es un poco conservador: no le da "excelente" porque su participación no es constante.

Interpreta que se desempeña bien, pero puede mejorar asistiendo más.

✅ Regla 5:

ctrl.Rule(asistencia['alta'] & nota['medio'], desempeno['aceptable'])


🧠 Significado:

"Si el estudiante tiene alta asistencia pero nota media, entonces su desempeño es aceptable."

El estudiante es constante en la asistencia, pero sus notas son promedio.

Esta regla reconoce el esfuerzo (asistencia alta) pero también que necesita mejorar el rendimiento académico.


✅ Regla 6:
ctrl.Rule(asistencia['baja'] & nota['alto'], desempeno['aceptable'])


🧠 Significado:

"Si el estudiante tiene baja asistencia pero nota alta, entonces su desempeño es aceptable."

Este caso representa a un estudiante que no va mucho a clase, pero aun así rinde bien.

El sistema reconoce su rendimiento, pero penaliza un poco la baja participación.

Por eso no da "excelente", sino "aceptable".

✅ Regla 7:

ctrl.Rule(asistencia['alta'] & nota['bajo'], desempeno['deficiente'])



| Asistencia | Nota  | Resultado esperado | Lógica detrás                                                            |
| ---------- | ----- | ------------------ | ------------------------------------------------------------------------ |
| Baja       | Baja  | Deficiente         | Nada va bien                                                             |
| Media      | Media | Aceptable          | Rendimiento promedio                                                     |
| Alta       | Alta  | Excelente          | Excelente comportamiento y rendimiento                                   |
| Media      | Alta  | Aceptable          | Buen rendimiento, pero le falta más compromiso                           |
| Alta       | Media | Aceptable          | Se esfuerza y participa, pero necesita mejorar el rendimiento            |
| Baja       | Alta  | Aceptable          | Buen rendimiento pese a poca asistencia, pero eso afecta el juicio final |
| Alta       | Baja  | Deficiente         | Participa, pero no entiende o no rinde; requiere intervención académica  |








Mensajes de error si se pone numero superior:
import numpy as np
import skfuzzy as fuzz
import skfuzzy.control as ctrl
import tkinter as tk
from tkinter import messagebox

# SISTEMA DIFUSO SKFUZZY

# 1. Definición de variables 
asistencia = ctrl.Antecedent(np.arange(0, 101, 1), 'asistencia')
nota = ctrl.Antecedent(np.arange(0, 11, 0.1), 'nota')
desempeno = ctrl.Consequent(np.arange(0, 101, 1), 'desempeño')

# 2. Conjuntos difusos
asistencia['baja'] = fuzz.trimf(asistencia.universe, [0, 0, 60])
asistencia['media'] = fuzz.trimf(asistencia.universe, [40, 70, 90])
asistencia['alta'] = fuzz.trimf(asistencia.universe, [60, 100, 100])

nota['bajo'] = fuzz.trimf(nota.universe, [0, 0, 6])
nota['medio'] = fuzz.trimf(nota.universe, [4, 6, 8])
nota['alto'] = fuzz.trimf(nota.universe, [6, 10, 10])

desempeno['deficiente'] = fuzz.trimf(desempeno.universe, [0, 30, 50])
desempeno['aceptable'] = fuzz.trimf(desempeno.universe, [40, 60, 75])
desempeno['excelente'] = fuzz.trimf(desempeno.universe, [70, 90, 100])

# 3. Reglas difusas
reglas = [
    ctrl.Rule(asistencia['baja'] & nota['bajo'], desempeno['deficiente']),
    ctrl.Rule(asistencia['media'] & nota['medio'], desempeno['aceptable']),
    ctrl.Rule(asistencia['alta'] & nota['alto'], desempeno['excelente']),
    ctrl.Rule(asistencia['media'] & nota['alto'], desempeno['aceptable']),
    ctrl.Rule(asistencia['alta'] & nota['medio'], desempeno['aceptable']),
    ctrl.Rule(asistencia['baja'] & nota['alto'], desempeno['aceptable']),
    ctrl.Rule(asistencia['alta'] & nota['bajo'], desempeno['deficiente'])
]

sistema_ctrl = ctrl.ControlSystem(reglas)
evaluador = ctrl.ControlSystemSimulation(sistema_ctrl)

# INTERFAZ GRÁFICA

class StudentFuzzyGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("Evaluador Difuso de Estudiantes")
        self.root.geometry("850x600")
        self.root.configure(bg="#e0f7fa")
        self.username = ""
        self.create_login_screen()

    def create_login_screen(self):
        for widget in self.root.winfo_children():
            widget.destroy()
        tk.Label(self.root, text="Sistema difuso de evaluación académica", font=("Helvetica", 18), bg="#e0f7fa").pack(pady=40)
        tk.Label(self.root, text="Ingrese su nombre:", font=("Helvetica", 14), bg="#e0f7fa").pack()
        self.username_entry = tk.Entry(self.root, font=("Helvetica", 14))
        self.username_entry.pack(pady=10)
        tk.Button(self.root, text="Ingresar", font=("Helvetica", 14), command=self.start_system, bg="#00796b", fg="white").pack(pady=20)

    def start_system(self):
        name = self.username_entry.get().strip()
        if not name:
            messagebox.showwarning("Advertencia", "Debe ingresar un nombre.")
            return
        self.username = name
        self.create_main_screen()

    def create_main_screen(self):
        for widget in self.root.winfo_children():
            widget.destroy()
        tk.Label(self.root, text=f"Hola, {self.username}", font=("Helvetica", 16, "bold"), bg="#e0f7fa").pack(pady=10)
        tk.Label(self.root, text="Ingrese el porcentaje de asistencia (%):", font=("Helvetica", 14), bg="#e0f7fa").pack()
        self.att_entry = tk.Entry(self.root, font=("Helvetica", 14))
        self.att_entry.pack(pady=5)
        tk.Label(self.root, text="Ingrese el promedio de notas (0-10):", font=("Helvetica", 14), bg="#e0f7fa").pack()
        self.grade_entry = tk.Entry(self.root, font=("Helvetica", 14))
        self.grade_entry.pack(pady=5)
        tk.Button(self.root, text="Evaluar", font=("Helvetica", 14), command=self.process_input, bg="#0288d1", fg="white").pack(pady=20)
        self.result_text = tk.Text(self.root, height=20, font=("Courier", 11), width=95, bg="#ffffff", wrap="word")
        self.result_text.pack(pady=10)

    def process_input(self):
        try:
            att = float(self.att_entry.get())
            grade = float(self.grade_entry.get())
            
            # VALIDACIONES agregadas aquí 👇
            if att < 0 or att > 100:
                messagebox.showerror("Error", "La asistencia debe estar entre 0 y 100.")
                return
            if grade < 0 or grade > 10:
                messagebox.showerror("Error", "La nota debe estar entre 0 y 10.")
                return

        except ValueError:
            messagebox.showerror("Error", "Ingrese valores numéricos válidos.")
            return

        # Evaluación con lógica difusa
        evaluador.input['asistencia'] = att
        evaluador.input['nota'] = grade
        evaluador.compute()
        resultado = evaluador.output['desempeño']

        # Mostrar resultados
        self.result_text.delete(1.0, tk.END)
        self.result_text.insert(tk.END, "------ FUSIFICACIÓN ------\n")
        for name, mf in asistencia.terms.items():
            val = fuzz.interp_membership(asistencia.universe, mf.mf, att)
            self.result_text.insert(tk.END, f"Asistencia '{name}': {val:.2f}\n")
        for name, mf in nota.terms.items():
            val = fuzz.interp_membership(nota.universe, mf.mf, grade)
            self.result_text.insert(tk.END, f"Nota '{name}': {val:.2f}\n")

        self.result_text.insert(tk.END, "\n------ REGLAS APLICADAS ------\n")
        for idx, rule in enumerate(sistema_ctrl.rules):
            a = rule.antecedent
            self.result_text.insert(tk.END, f"Regla {idx+1}: SI {a} → {rule.consequent}\n")

        self.result_text.insert(tk.END, "\n------ DESFUSIFICACIÓN ------\n")
        self.result_text.insert(tk.END, f"Resultado final (desempeño): {resultado:.2f} / 100\n")

        self.result_text.insert(tk.END, "\n------ EVALUACIÓN FINAL ------\n")
        if resultado < 50:
            estado = "RENDIMIENTO DEFICIENTE - Se recomienda reforzar el estudio y mejorar la asistencia."
        elif resultado < 75:
            estado = "RENDIMIENTO ACEPTABLE - Buen trabajo, sigue así."
        else:
            estado = "RENDIMIENTO EXCELENTE - ¡Felicidades!"

        self.result_text.insert(tk.END, f"Estado del estudiante: {estado}\n")


# EJECUCIÓN DEL SISTEMA
if __name__ == "__main__":
    root = tk.Tk()
    app = StudentFuzzyGUI(root)
    root.mainloop()




OTRAS COSAS AGREGADAS (NO IMPORTANTES)
    def process_input(self):
        try:
            att = float(self.att_entry.get())
            grade = float(self.grade_entry.get())
            
            # VALIDACIONES agregadas aquí 👇
            if att < 0 or att > 100:
                messagebox.showerror("Error", "La asistencia debe estar entre 0 y 100.")
                return
            if grade < 0 or grade > 10:
                messagebox.showerror("Error", "La nota debe estar entre 0 y 10.")
                return

        except ValueError:
            messagebox.showerror("Error", "Ingrese valores numéricos válidos.")
            return

        # Evaluación con lógica difusa
        evaluador.input['asistencia'] = att
        evaluador.input['nota'] = grade
        evaluador.compute()
        resultado = evaluador.output['desempeño']

        # Mostrar resultados
        self.result_text.delete(1.0, tk.END)
        self.result_text.insert(tk.END, "------ FUSIFICACIÓN ------\n")
        for name, mf in asistencia.terms.items():
            val = fuzz.interp_membership(asistencia.universe, mf.mf, att)
            self.result_text.insert(tk.END, f"Asistencia '{name}': {val:.2f}\n")
        for name, mf in nota.terms.items():
            val = fuzz.interp_membership(nota.universe, mf.mf, grade)
            self.result_text.insert(tk.END, f"Nota '{name}': {val:.2f}\n")

        self.result_text.insert(tk.END, "\n------ REGLAS APLICADAS ------\n")
        for idx, rule in enumerate(sistema_ctrl.rules):
            a = rule.antecedent
            self.result_text.insert(tk.END, f"Regla {idx+1}: SI {a} → {rule.consequent}\n")

        self.result_text.insert(tk.END, "\n------ DESFUSIFICACIÓN ------\n")
        self.result_text.insert(tk.END, f"Resultado final (desempeño): {resultado:.2f} / 100\n")

        self.result_text.insert(tk.END, "\n------ EVALUACIÓN FINAL ------\n")
        if resultado < 50:
            estado = "RENDIMIENTO DEFICIENTE - Se recomienda reforzar el estudio y mejorar la asistencia."
        elif resultado < 75:
            estado = "RENDIMIENTO ACEPTABLE - Buen trabajo, sigue así."
        else:
            estado = "RENDIMIENTO EXCELENTE - ¡Felicidades!"
        self.result_text.insert(tk.END, f"Estado del estudiante: {estado}\n")

        # 🔍 ANÁLISIS ADICIONAL AUTOMÁTICO
        self.result_text.insert(tk.END, "\n------ ANÁLISIS ADICIONAL ------\n")

        fortalezas = []
        mejoras = []

        # Análisis de asistencia
        if att >= 85:
            fortalezas.append("Asistencia")
        elif att < 60:
            mejoras.append("Asistencia")

        # Análisis de nota
        if grade >= 8.5:
            fortalezas.append("Nota")
        elif grade < 6:
            mejoras.append("Nota")

        # Mostrar análisis
        self.result_text.insert(tk.END, f"Fortalezas detectadas: {', '.join(fortalezas) if fortalezas else 'Ninguna'}\n")
        self.result_text.insert(tk.END, f"Áreas de mejora: {', '.join(mejoras) if mejoras else 'Ninguna'}\n")
